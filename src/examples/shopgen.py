import math
import random
import unittest
import itertools
import contextlib
from copy import deepcopy
from itertools import repeat, product
from functools import wraps, reduce
from operator import mul
import torch.optim as optim
import numpy as np
from tqdm import tqdm
import torch as t
import torch.nn as nn
import torch.nn.functional as F
import torch.nn.parallel as dp
import torch.nn.init as init
import torch.nn.utils as nn_utils
import torch.nn.utils.rnn as rnn_utils
from torch.nn.utils import clip_grad_norm
from torch.autograd import Variable, gradcheck
from torch.nn import Parameter
from sklearn.preprocessing import OneHotEncoder
from numpy.lib.stride_tricks import as_strided
import rnn

class Bunch:
    def __init__(self, **kwds):
        self.__dict__.update(kwds)

class shopgen:
    '''
    infwin = influence window: if trigger happens at window ending at index i,
             how many steps AFTER i does the influence persist?
    '''
    def __init__(self, carts, win, infwin, future, buy=2, prob=0.7):
        self.lookback = win + infwin - 1 # for given index i, oldest index that can influce i is i-lookback
        self.win = win
        self.infwin = infwin
        self.future = future
        self.carts = carts
        self.buy = 2
        self.p = prob

    # create nWindows x windowSize array
    def roll_windows(self, seq, window=5):
        stride = seq.strides[0]
        sequence_strides = as_strided(seq, shape=[len(seq) - window + 1, window], strides=[stride, stride])
        return sequence_strides

    def shop_trigger(self, seq):
        '''
        Given a seq and a window-size w, find if there is a window of size w within seq
        that satisfies trigger condition.
        '''
        if len(seq) < self.win:
            return False, -1
        wins = self.roll_windows(seq, self.win)  # rolling windows of size w
        ones = 1 * (wins == 1)  # indicators of 1
        win_ones = sum(np.transpose(ones))  # how many 1s in each window
        wins_at_least_c = np.where(win_ones >= self.carts)[0]  # which windows have at least c ones
        if len(wins_at_least_c) == 0:
            return False, -1
        last_good_win = np.max(wins_at_least_c)
        buys = np.count_nonzero(seq[last_good_win:] == self.buy)
        if buys == 0:  # no buys since last good window
            return True, last_good_win
        else:
            return False, last_good_win

    '''
    Similar to the `seq-pred` but the X-sequence will now represent the sequence of events generated by an online shopper. There will be 3 types of events:

    - 0 = product browse
    - 1 = carting
    - 2 = purchase / convert

    An X event at index i will be characterized by the probability-vector ("ProbVec") of the 3 possible actions (0,1,2), defined by the following rules:

    ```python
    if i < L:
        ProbVec = (0.5, 0.5, 0.0)
    else if there are at least c cart events (1 values) within a w-day window during over the past L days
    ProbVec = (0.15, 0.15, 0.70)
    else:
    ProbVec = (0.5, 0.5, 0.0)
    ```
    The task is to predict whether there will be a Purchase event (2) over the next `f` time-steps. The "Teaching sequence" `Y` will provide this for training.
    '''
    def gen_shopper_x(self, size):
        x = np.random.binomial(1, 0.5, self.lookback)
        for i in range(size - self.lookback):
            recent = x[-self.lookback:]
            trig, _ = self.shop_trigger(recent)
            if trig:
                pvals = [(1-self.p)/2, (1-self.p)/2, self.p]
            else:
                pvals = [0.5, 0.5, 0.0]
            new_x = np.where(np.random.multinomial(1, pvals, 1)[0])[0][0]
            x = np.append(x, new_x)
        return x

    '''
    Is there at least one buy AFTER index i?
    '''

    def gen_shopper_y(self, x, i):
        return 1 * (sum(1 * (x[i+1 : ] == self.buy)) > 0)

    '''
    Given we are at index i in x-sequence, (i.e. have seen x until index i),
     what is our ideal prediction of:
      Prob(shopping event (2) within forecast window k starting at i+1)?

     We assume this function is invoked with a slice of array x that
     contains indices i-LookbackWin, ... i+2, i+2, ... i+k
     where k = forecast window (fwin param)


    '''
    def gen_shopper_y_py(self, x, i):
        trig, last = self.shop_trigger(x[max(0, i+1-self.lookback) : i+1])
        if trig:
            infwin_fwin_overlap = min(self.future, last + self.win + self.infwin - i - 1)
            if infwin_fwin_overlap <= 0:
                return 0, 0.0
            else:
                will_buy =  1 * (sum(1 * (x[i+1 : ] == self.buy)) > 0)
                return will_buy, 1 - np.power(1 - self.p, infwin_fwin_overlap)
        else:
            return 0, 0.0


    def gen_xy(self, size):
        x = self.gen_shopper_x(size)
        y = []
        py = []
        loss = 0
        for i in range(size):  # don't care about indexes here
            start_idx = max(0, i - self.lookback + 1)
            newy, newpy = self.gen_shopper_y_py(x[start_idx : i + self.future + 1], i - start_idx)
            y = np.append(y, newy)
            py = np.append(py, newpy)
            loss += - newy * np.log(newpy + 0.000001) - (1-newy) * np.log(1.0 - newpy)

        emp_py = np.sum(y)/size
        emploss = - emp_py * np.log(emp_py) - (1 - emp_py)*np.log(1 - emp_py)
        return x, y, py, loss/size, emploss

    def gen_tensors(self, nt=15, nb=50, nf=1, fill='rand', minlen=0.5, gpu=False, xhot=False, yhot=False):
        size = nt * nb
        X, Y, py, loss, emp = self.gen_xy(size)
        tx = t.Tensor(X).view(nb, nt, nf).transpose(0, 1)
        ty = t.Tensor(Y).view(nb, nt, nf).transpose(0, 1)
        # fill in initial "xstart" elements of each seq with rand values
        if fill == 'zero':
            ty[:self.win, :, :] = 0.0
        if xhot:
            tx = rnn.one_hot(tx)
        if yhot:
            ty = rnn.one_hot(ty)

        if gpu:
            x = tx.cuda()
            y = ty.cuda()
        else:
            x = tx
            y = ty

        lengths = -np.sort(-np.random.random_integers(int(nt * minlen), nt, nb))
        return Bunch(xvec = X, yvec = Y, py = py, x=x, y=y, lengths=lengths, loss=loss, emp=emp)


# test
g = shopgen(2,4,3,3)
x, y, py, loss, emp = g.gen_xy(500)
np.transpose(np.stack([x,y,py]))

b = g.gen_tensors(nt=200, nb=50, minlen = 1)