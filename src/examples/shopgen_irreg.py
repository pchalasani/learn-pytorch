import math
import random
import unittest
import itertools
import contextlib
from copy import deepcopy
from itertools import repeat, product
from functools import wraps, reduce
from operator import mul
import torch.optim as optim
import numpy as np
from tqdm import tqdm
import torch as t
import torch.nn as nn
import torch.nn.functional as F
import torch.nn.parallel as dp
import torch.nn.init as init
import torch.nn.utils as nn_utils
import torch.nn.utils.rnn as rnn_utils
from torch.nn.utils import clip_grad_norm
from torch.autograd import Variable, gradcheck
from torch.nn import Parameter
from sklearn.preprocessing import OneHotEncoder
from sklearn.metrics import roc_auc_score
from numpy.lib.stride_tricks import as_strided
import rnn

class Bunch:
    def __init__(self, **kwds):
        self.__dict__.update(kwds)

class shopgen_irreg:
    '''
    Similar to shopgen except that the sequence x is now not just an action (0,1,2),
    but is a tuple (action, lag) where lag is the time-since-last-action
    (or some large number if no such action exists).

    All windows have time-units in seconds (rather than time-steps).

    infwin = influence window: if trigger happens at window ending at index i,
             how many steps AFTER i does the influence persist?
    snoop: indicates whether the teaching signal y should snoop into the future
           to indicate whether there WILL be a buy or not
    mean_lag = mean inter-arrival time for exponential distribution
    '''
    def __init__(self, carts, win, infwin, future, buy=2, prob=0.7, snoop = True, mean_lag = 5 ):
        self.lookback = win + infwin - 1 # for given index i, oldest time that can influce i is i-lookback
        self.win = win
        self.infwin = infwin
        self.future = future
        self.carts = carts
        self.buy = 2
        self.p = prob
        self.snoop = snoop
        self.mean_lag = mean_lag

    # create nWindows x windowSize array
    def roll_windows(self, seq, window=5):
        stride = seq.strides[0]
        sequence_strides = as_strided(seq, shape=[len(seq) - window + 1, window], strides=[stride, stride])
        return sequence_strides

    def shop_trigger(self, seq):
        '''
        Given a seq and a window-size w, find if there is a window of size w within seq
        that satisfies trigger condition.
        '''
        if len(seq) < self.win:
            return False, -1
        wins = self.roll_windows(seq, self.win)  # rolling windows of size w
        ones = 1 * (wins == 1)  # indicators of 1
        win_ones = sum(np.transpose(ones))  # how many 1s in each window
        wins_at_least_c = np.where(win_ones >= self.carts)[0]  # which windows have at least c ones
        if len(wins_at_least_c) == 0:
            return False, -1
        last_good_win = np.max(wins_at_least_c)
        buys = np.count_nonzero(seq[last_good_win:] == self.buy)
        if buys == 0:  # no buys since last good window
            return True, last_good_win
        else:
            return False, last_good_win

    def recent_events(self, seq, w = -1):
        '''
        given 'seq' of event-lag pairs,
        return events within 'win' time-units from the end of the seq
        '''
        span, i = 0, 0
        if w < 0:
            w = self.win
        while i < len(seq) and span <= w:
            i += 1
            span += seq[-i][1]
        if i == 1:
            return []
        else:
            return seq[-(i-1):]

    def future_events(self, seq):
        return self.recent_events(seq[::-1], self.future)






    '''
    Similar to the `seq-pred` but the X-sequence will now represent the sequence of events generated by an online shopper. There will be 3 types of events:

    - 0 = product browse
    - 1 = carting
    - 2 = purchase / convert

    An X event at index i will be characterized by the probability-vector ("ProbVec") of the 3 possible actions (0,1,2), defined by the following rules:

    ```python
    if i < L:
        ProbVec = (0.5, 0.5, 0.0)
    else if there are at least c cart events (1 values) within a w-day window during over the past L days
    ProbVec = (0.15, 0.15, 0.70)
    else:
    ProbVec = (0.5, 0.5, 0.0)
    ```
    The task is to predict whether there will be a Purchase event (2) over the next `f` time-steps. The "Teaching sequence" `Y` will provide this for training.
    '''
    def gen_shopper_x(self, size):
        x = np.random.binomial(1, 0.5, self.lookback)
        lags = [max(lag,1) for lag in  np.round(np.random.exponential(self.mean_lag, self.lookback))]
        for i in range(size - self.lookback):
            recent = x[-self.lookback:]
            trig, _ = self.shop_trigger(recent)
            if trig:
                pvals = [(1-self.p)/2, (1-self.p)/2, self.p]
            else:
                pvals = [0.5, 0.5, 0.0]
            new_x = np.where(np.random.multinomial(1, pvals, 1)[0])[0][0]
            new_lag = max(1, np.round(np.random.exponential(self.mean_lag)))
            x = np.append(x, new_x)
            lags = np.append(lags, new_lag)
        return zip(x, lags)



    def gen_shopper_y(self, x, i):
        '''

        :param x: sequence of (event,lag) tuples
        :param i: last index of x that is seen
        :return: whether or not there is a buy event (2) within 'future' seconds AFTER current time.
        '''
        tuples_after = self.future_events(x[i+1:]) + [(0,0), (0,0)] # add dummies to avoid edge cases
        events_after = np.array(zip( *tuples_after )[0])
        return 1 * (sum(1 * (events_after == self.buy)) > 0)

    '''
    helper used in gen_shopper_y_py;
    Given we're at position i in x,
    and we have seen window "win" ending at i,
    what is the probability that the trigger is satisfied
    for AT LEAST one of the windows ending
    where f is the "future" window size (forecast horizon)

    '''

    def gen_xy(self, size):
        x = self.gen_shopper_x(size)
        y = []
        loss = 0
        for i in range(size):  # don't care about indexes here
            start_idx = max(0, i - self.lookback + 1)
            newy = self.gen_shopper_y(x[start_idx : i + self.future + 1], i - start_idx)
            y = np.append(y, newy)
        emp_py = np.sum(y)/size
        emploss = - emp_py * np.log(max(1e-5,emp_py)) - (1 - emp_py)*np.log(max(1e-5, 1 - emp_py))
        return x, y, emploss

    def gen_tensors(self, nt=15, nb=50, nf=1, fill='rand', minlen=0.5, gpu=False, xhot=False, yhot=False):
        size = nt * nb
        X, Y, emp = self.gen_xy(size)
        x_events, x_lags  = zip(*X)
        tx_events = t.Tensor(x_events).view(nb, nt, nf).transpose(0, 1)
        tx_lags = t.Tensor(x_lags).view(nb, nt, 1).transpose(0, 1)
        ty = t.Tensor(Y).view(nb, nt, nf).transpose(0, 1)

        # fill in initial "xstart" elements of each seq with rand values
        if fill == 'zero':
            ty[:self.win, :, :] = 0.0
        if xhot:
            tx_events = rnn.one_hot(tx_events)
        if yhot:
            ty = rnn.one_hot(ty)

        tx = t.cat([tx_events, tx_lags], 2)
        if gpu:
            x = tx.cuda()
            y = ty.cuda()
        else:
            x = tx
            y = ty

        lengths = -np.sort(-np.random.random_integers(int(nt * minlen), nt, nb))
        return Bunch(xvec = X, yvec = Y, x=x, y=y, lengths=lengths, emp=emp)


# test
g = shopgen_irreg(3,20,5,10, mean_lag= 5)
evs = g.gen_shopper_x(20)
recent = g.recent_events(evs)
fut = g.future_events(evs)
(recent, fut)
g.gen_shopper_y(evs,3)

# np.transpose(np.stack([x,y,py]))

# b = g.gen_tensors(nt=200, nb=50, minlen = 1)


# g = shopgen(carts=3, win=6, infwin=3, future=3)
x, y, emp =  g.gen_xy(40)
#np.transpose(np.stack([x,y]))

b = g.gen_tensors(15,5, xhot = True)

